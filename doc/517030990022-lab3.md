# Lab 3

## Exercise 2:

process_create_root

- create a root process so os can run some threads. Else, the os will empty without user program and will just stall

call graph:

- process_create_root -> ramdisk_read_file(to read binary user file. Abbreviated here using TEST via linker) -> process_create(to alloc new process, slot_id, cap, etc and place in slot list) -> thread_create_main(to alloc PMI, caps, stack space, load binary, do mapping, ...) -> load_binary(load binary as in elf_header)

thread_create_main:

- obj_alloc, pmo_init, cap_alloc: Allocate and setup a user stack for the init thread
- vmspace_map_range: map stack va to pa
- load_binary: load user bin file that contain elf entries to address then map them to ttbr_el0
- prepare_env: prepare stack space
- thread_init: set up thread attributes to call it later in eret_to_thread()

## Exercise 4:

When there is an exception, pc will directly jump to a specific memory region offset relative to VBAR_EL1 then start execution. So we will need to fill every entry with fixed alignment of 0x80 aligned region with specific B code to jump to other handler program. We can do this via exception_entry which has an alignment of 0x80 set. Then, with proper error code, we can jump to handler_c to handle any exception there.

## Exercise 7:

START will set up necessary registers then branch to _start_c in user space. The main() in _start_c will be linked by linker to a specific root user program entrypoint during process_create_root(). Then our program will start to run.