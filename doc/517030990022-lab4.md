# Lab 4

## Question 1:

As previously done, chcore bootloader will store the processor id in x8 and do comparison. If it is primarily masked, will jump to primary which will do all the booting initialization. 

For the other APs, they will continue downwards until reach hang. Here, it will check a memory in secondary boot flag and keep looping until the flag is not zero. 

If the memory set to non zero by BSP, will continue downwards to secondary_continue_boot and then run secondary_init_c

## Question 3:

BSP activates AP one by one. Simultaneous activation will cause problems. Each cpu share different stack and will activate the kernel stack in secondary_cpu_boot. However if they perform concurrently, the assembly instruction here will be handled concurrently too and the initialized processor stack will be wrong. There will be race condition.

## Question 6:

In exception_enter, we have saved all register values from user mode into kernel stack. And in exception_exit, we will restore them. So unlock_kernel do not need to do anything as no argument needed.
In sync_el0_64, there are some operations done before acquired lock when entering kernel mode. So we need to save and restore those registers as lock_kernel might change some registers' value.

## Question 8:

because during eret_to_thread when context switch, os called exception_exit which release lock. So if current thread is idle and we want to use exception_exit again after handling all interrupt, we will have no lock to release. So it is logical that we need to gain the lock on this idle thread interrupt entrypoint.