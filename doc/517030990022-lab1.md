# Lab 1 Documents  

## Part A: Bootstrap  

### exercise 2:

After using where command in gdb, result obtained is  
```
(gdb) where
#0  0x0000000000080000 in _start ()
```
meaning, the entry function is _start() at address 0x80000  

## PartB: The Boot Loader  

### exercise 3:  

First, the entry program will get the current processor id. Then, the program will check if it is the main processor. If yes, program will jump to a label that set exception level, entering init_c, entering start_kernel... Else, program will continue downwards without jumping and keep looping inside label secondary_hang.  

### exercise 5:  

- .init VMA and LMA are the same because they are small and loaded into memory or processor cache to be executed right away each time processor boots.
- .text VMA and LMA are different because they contain kernel codes which are big and should be loaded into ROM first and swapped into RAM only when needed(after boot completes).  

## Part C: The Kernel  

### exercise 7:  

Bootloader initially set up SP to be boot_cpu_stack + 0x1000. However, when entering kernel, the kernel stack address starts in memory of 0xffffff00000d00f0(kernel_stack). The kernel reserve space by taking KERNEL_STACK_SIZE(8K defined in vars.h) and then added with the original stack border address to place the highest stack address into SP.  

### exercise 8:  

Each recursion pushes 3 64bits register value onto stack using the stp and str command. They are x19(argument), x29 and x30. When calling subroutine, return address (x30), frame pointer (x29) are stored in stack using stp command so that they are aligned.  



*MENG YIT KOH 517030990022*